#!/usr/bin/env python
""" Finish Line!  A CLI tool for wrapping up your sprints.

See the README for more information.

Author:  Ralph Bean <rbean@redhat.com>

"""
from __future__ import print_function

import argparse
import collections
import datetime
import defaults
import os
import re
import six
import sys
import traceback

from mosaic import mosaic

try:
    import configparser
except ImportError:
    import ConfigParser as configparser


try:
    import bs4
    import docutils.examples
    import jinja2

    import jira
except ImportError as error:
    print('ERROR: Unable to import required libraries. '
          'Ensure all libraries in requirements.txt are installed.')
    print(error)
    raise SystemExit(1)


custom_filters = {
    'slugify': lambda x: x.lower().replace(' ', '-'),
    'rst2html': lambda rst: docutils.examples.html_parts(
        rst, input_encoding='utf-8')['body'],
    'replace': lambda string, char: char * len(string),
}


def scrape_links(session, args):
    response = session.get(args.server)
    soup = bs4.BeautifulSoup(response.text, 'html5lib')
    return [l.text for l in soup.find(id='content').findAll('a')[5:]]


def parse_arguments():
    arg_parser = argparse.ArgumentParser(add_help=False)
    arg_parser.add_argument('-c', '--config', required=True,
                            help='Path to the Finishline config file')
    arg_parser.add_argument('-s', '--scenario',
                            help=('A scenario to run in. This should '
                                  'correspond to a block in the config '
                                  'file. Options specified in the scenario '
                                  'block will override the values specified '
                                  'in the options section.'))

    return arg_parser.parse_args()


def get_config(config_file_path):
    config = configparser.SafeConfigParser()
    config.read(config_file_path)

    return config


def render(tpl, args, data):
    """
    Renders a template based on input.

    :param tpl: The template to render.
    :type tpl: str
    :param args: Arguments to pass to jinja2.Template.render.
    :type args: argparse.Namespace
    :param data: Data to pass in as part of the render context
    :type data: dict
    """
    env = jinja2.Environment(
        loader=jinja2.FileSystemLoader('templates'),
    )
    env.filters.update(custom_filters)
    template = env.get_template(tpl)

    data = data.copy()

    data['today'] = datetime.datetime.utcnow().strftime(defaults.DATE_FORMAT)

    for arg, value in args.items():
        try:
            # Code path for Python2 strings.
            # Explicitly convert the string to unicode
            data[arg] = value.decode('utf-8')
        except AttributeError:
            # Either the attribute is not a string, or we're
            # running Python 3 and the string is already unicode
            data[arg] = value

    # If refernces exists in the namespace AND it results in a bool True
    if 'references' in args:
        references = env.get_template(args['references'])
        data['references'] = references.render(**data)

    return template.render(**data)


def _split_context(context_data):
    """
    Splits k=v,k=v,.. strings into a dictionary.

    :param context_data: key=val list
    :type context_data: list
    :returns: A parsed context
    :rtype: dict
    :raises: IndexError
    """
    result = {}
    for item in context_data:
        k, v = item.split('=')
        result[k] = v
    return result


def pull_issues(client, args):
    # Get any extra context items for the query
    query_context = _split_context(args.get('query_context', ''))
    # Render the template with extra context into a query we can use
    query = render(args['query_template'], args, query_context)
    print(query, file=sys.stderr)
    issues = client.search_issues(query, maxResults=999)
    # NOTE: since this yields functionality won't occur until the first
    # iteration over the return value
    for issue in issues:
        yield issue


def extract_status_update(args, epic):
    sentinnels = [
        'h1. Status Update:',
        'Status Update:',
        'h1. Status Update',
        'Status Update',
    ]
    for comment in reversed(epic.fields.comment.comments):
        for sentinnel in sentinnels:
            body = comment.body
            if body.startswith(sentinnel):
                # Attach a cleaned version for the template.
                body = body[len(sentinnel):].strip()
                body = body.split('\n')[0].strip()

                # Replace [~username] with **@username** to not
                # freakout google.
                body = re.sub(r'\[\~([a-zA-Z]+)\]', r'**@\1**', body)

                comment.cleaned = body
                return comment


def extract_objective(args, epic):
    try:
        for link in epic.raw['fields'].get('issuelinks', []):
            if link['type']['inward'] == 'is subtask of':
                return link['inwardIssue']['fields']['summary']
        return args['placeholder_objective']
    except KeyError:
        msg = 'Error determining objective for epic {0}: {1}'
        print(msg.format(epic, traceback.format_exc()), file=sys.stderr)
        raise


def extract_mvp_status(args, epic):
    return epic.raw['fields'].get(args['mvp_status_field'])


def extract_target_date(args, epic):
    return epic.raw['fields']['duedate'] or ''


def extract_owner(args, epic):
    return epic.raw['fields']['assignee']


def extract_percent_complete(client, args, epic):
    query = render(args['okr_query_template'], args, {'epic_key': epic.key})
    issues = client.search_issues(query)
    total_points = sum([
        i.raw['fields'][args['story_point_field']] or args['default_story_points']
        for i in issues
    ])
    closed_points = sum([
        i.raw['fields'][args['story_point_field']] or args['default_story_points']
        for i in issues
        if i.raw['fields']['resolution']
    ])
    if total_points:
        percent = float(float(closed_points) / float(total_points) * 100)
        percent = '%0.1f' % percent
        return percent
    else:
        return "nan"  # not a number


def get_epic_details(client, args, key):
    if not key:
        return None
    epic = client.issue(key)

    # epic.image_url = 'https://placekitten.com/1600/900'
    epic.percent_complete = extract_percent_complete(client, args, epic)
    epic.status_update = extract_status_update(args, epic)
    epic.mvp_status = extract_mvp_status(args, epic)
    epic.target_date = extract_target_date(args, epic)
    epic.owner = extract_owner(args, epic)
    epic.objective = extract_objective(args, epic)
    epic.story_count = 0
    epic.done_count = 0

    return epic


def _run_mosaic(args, start_date, end_date):
    args['begin_date'] = start_date
    args['end_date'] = end_date
    try:
        return mosaic.run(args, client)
    except ZeroDivisionError:
        return 'NAN: No data'


def _calculate_mosaic_progress(baseline, current, target):
    if current == 'NAN: No data':
        return current
    baseline = float(baseline)
    current = float(current)
    delta_begin_index = 0
    if target[0] == '-':
        operator = '-'
        delta_begin_index = 1
    else:
        operator = '+'

    if target[-1] == '%':
        delta = '.' + target[delta_begin_index:-1]
        delta = float(delta) * baseline
    else:
        delta = target[delta_begin_index:]
    delta = float(delta)

    if operator == '-':
        status = (baseline - current) / delta
    else:
        status = (current - baseline) / delta

    return '{0:0.1f}'.format(status * 100)


def get_mosaic_status(epics, project, jira_client, mosaic_config_file):
    mosaic_config = configparser.ConfigParser()
    mosaic_config.read(mosaic_config_file)
    mosaic_config = mosaic_config._sections
    mosaic_issues = mosaic_config['mosaic'].get('mosaic_issues', '')
    print(('Mosaic will be used to determine status for the following '
          'issues: {issues}').format(issues=mosaic_issues), file=sys.stderr)
    common_mosaic_args = {
        'auto_mode': True,
        'project': project,
    }
    baseline_start = mosaic_config['mosaic']['baseline_start']
    baseline_end = mosaic_config['mosaic']['baseline_end']
    current_start = mosaic_config['mosaic']['current_period_start']
    current_end = mosaic_config['mosaic']['current_period_end']
    for issue in mosaic_issues.split(','):
        if not issue or issue == '':
            continue
        mosaic_args = {}
        mosaic_args.update(common_mosaic_args)
        print(('Executing mosaic to get status for '
               'issue {0}').format(issue), file=sys.stderr)
        assert issue in mosaic_config
        issue_config = mosaic_config[issue]
        mosaic_args['query'] = [issue_config['query']]
        mosaic_args['query_argument'] = issue_config.get('query_argument', '')
        baseline = _run_mosaic(mosaic_args, baseline_start, baseline_end)
        # Only enable the rolling argument, if specified, for getting the
        # current progress on an issue. The baseline date range should not
        # include today, and the rolling argument is not supported for date
        # ranges that don't include today.
        mosaic_args['rolling'] = bool(issue_config.get('rolling', False))
        current = _run_mosaic(mosaic_args, current_start, current_end)
        progress = _calculate_mosaic_progress(baseline, current,
                                              issue_config['target'])
        epics[issue].percent_complete = progress


def collate_issues(client, args, issues):
    epics = {}
    objectives = collections.defaultdict(set)
    by_epic = collections.defaultdict(lambda: collections.defaultdict(set))

    # First, handle any explicitly listed epics, even if they have no curent
    # work in the `issues` list.
    for epic_key in args['include_epics']:
        if epic_key not in epics:
            epics[epic_key] = get_epic_details(client, args, epic_key)

        placeholder = args['placeholder_objective']
        objective = getattr(epics[epic_key], 'objective', placeholder)
        objectives[objective].add(epic_key)

    # Second, do our main work of processing the individual issues passed in.
    for issue in issues:
        epic_key = issue.raw['fields'][args['epic_field']]

        # Ignore orphan tasks, unassociated with an epic.
        if not epic_key:
            continue

        # If this is on a verboten epic, ditch it.
        if epic_key in args['hide_epics']:
            continue

        # Enrich with details
        if epic_key not in epics:
            epics[epic_key] = get_epic_details(client, args, epic_key)

        placeholder = args['placeholder_objective']
        objective = getattr(epics[epic_key], 'objective', placeholder)
        objectives[objective].add(epic_key)

        # Associate the issue with the enriched epic.
        print("Found %r on %r, under %r" % (issue.key, epic_key, objective),
              file=sys.stderr)
        category = issue.fields.status.raw['statusCategory']['name']
        epics[epic_key].story_count += 1
        if category == 'Done':
            epics[epic_key].done_count += 1
        issue.fields.key = issue.key
        by_epic[epic_key][category].add(issue.fields)

    # Bubble up the KR completion to an average value for the objective.
    objective_completion = {}
    for objective in objectives:
        objective_completion[objective] = sum(
            float(epic.percent_complete)
            for key, epic in list(epics.items())
            if key in objectives[objective]
        ) / len(objectives[objective])

    return dict(
        epics=epics,
        by_epic=by_epic,
        objectives=objectives,
        objective_completion=objective_completion,
    )


if __name__ == '__main__':
    import logging
    logging.basicConfig(level=logging.INFO)

    args = parse_arguments()
    config = get_config(args.config)._sections
    if 'scenario' in args and args.scenario is not None:
        config = defaults.override_scenario(config, args.scenario)
    config = defaults.set_defaults(config)
    config_options = config['options']

    # dynamically build the arguments to pass into jira.client.JIRA
    client_kwargs = {
        'server': config_options['server'],
        'options': dict(verify=config_options['cacert']),
    }
    # If we have a basic_auth argument set...
    if 'basic_auth' in config_options and config_options['basic_auth']:
        import getpass
        # ... use the value as the username
        username = config_options['basic_auth']
        # and get the password
        if config_options['service_account_password']:
            # user the service account password
            passwd = config_options['service_account_password']
        else:
            # prompt the user
            passwd = getpass.getpass()
        # Set both values in a tuple and use it when creating the client
        client_kwargs['basic_auth'] = (username, passwd)
        # Validate credentials first
        client_kwargs['validate'] = True
    else:
        # otherwise fall back to kerberos
        if 'auth_path' in config_options:
            client_kwargs['options'].update(dict(auth_url=config_options['auth_path']))
            client_kwargs['validate'] = True
        client_kwargs.update(
            dict(
                kerberos=True,
                kerberos_options=dict(mutual_authentication='DISABLED'),
            )
        )

    client = jira.client.JIRA(**client_kwargs)
    issues = pull_issues(client, config_options)
    data = collate_issues(client, config_options, issues)
    if 'mosaic_config' in config_options:
        print(('Mosaic config argument specified. Automatically '
               'calculating completion percentage for configured '
               'issues.'), file=sys.stderr)
        get_mosaic_status(data['epics'], config_options['project'], client,
                          config_options['mosaic_config'])
    output = render(config_options['template'], config_options, data)
    if isinstance(output, six.text_type):
        output = output.encode('utf-8')
        try:
            # Since we are supporting python 2 and 3 we need
            # to force ascii encoding before printing for python 3
            output = str(output, encoding='utf-8')
        except Exception:
            pass
    print(output)
